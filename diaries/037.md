# 037: ScriptContentDisplayコンポーネントの細分化成功！

## 今日の気持ち
もう〜、コンポーネントの細分化って本当に神経使うわね！でも、最終的に`ScriptContentDisplay.vue`が驚くほどスッキリしたのよ。400行以上もあった巨大なコンポーネントを、たった130行くらいまで削減できたの。これでメンテナンスが楽になるわね〜♪

## この記事で学べること
- Vue 3での大規模コンポーネントの効果的な細分化手法
- インライン編集機能をサブコンポーネントに分離する方法
- 親子間のイベント通信を適切に設計する方法
- コンポーネント間のデータフローを管理する方法

## 対象読者
- Vue 3で複雑なUIコンポーネントを開発しているエンジニア
- 大規模なコンポーネントのリファクタリングに悩んでいる開発者
- 台本エディターのようなリッチなUIを作成している人

## 実施した作業内容

### 1. 既存コンポーネントの状況確認
まず、既存の`ScriptContentDisplay.vue`は以下の問題を抱えていたの：
- 400行以上の巨大なコンポーネント
- シーンとセリフの編集ロジックが混在
- テンプレートが非常に複雑
- メンテナンスが困難

### 2. 細分化の戦略
以下の3つのコンポーネントに分離することにしたの：

#### ScriptContentDisplay.vue（親コンポーネント）
```vue
<template>
  <div class="bg-white rounded-lg shadow-sm border">
    <div class="p-6 border-b">
      <h2 class="text-xl font-semibold">{{ $t("scriptContent") }}</h2>
    </div>

    <div class="p-6">
      <div v-if="scriptContent && scriptContent.length > 0" class="space-y-4">
        <!-- 最初に追加ボタン（編集モードのみ） -->
        <div v-if="!readOnly" class="flex justify-center gap-2 py-2">
          <button
            @click="$emit('add-scene', 0)"
            class="px-3 py-1 bg-sky-100 text-sky-700 hover:bg-sky-200 rounded-md text-sm transition-colors"
          >
            + {{ $t("addScene") }}
          </button>
        </div>

        <div
          v-for="(scene, sceneIdx) in scriptContent"
          :key="scene.id"
          class="script-item-container"
        >
          <!-- シーンコンポーネント -->
          <SceneItem
            :scene="scene"
            :scene-index="sceneIdx"
            :available-characters="availableCharacters"
            :read-only="readOnly"
            :is-editing="editingItem === `scene-${sceneIdx}`"
            :can-move-up="sceneIdx > 0"
            :can-move-down="sceneIdx < scriptContent.length - 1"
            @start-edit="startSceneEdit(sceneIdx)"
            @save-edit="saveSceneEdit(sceneIdx, $event)"
            @cancel-edit="cancelInlineEdit"
            @delete="$emit('delete-scene', sceneIdx)"
            @move-up="$emit('move-scene', sceneIdx, sceneIdx - 1)"
            @move-down="$emit('move-scene', sceneIdx, sceneIdx + 1)"
            @add-line="$emit('add-line-to-scene', sceneIdx)"
            @delete-line="$emit('delete-line', sceneIdx, $event)"
            @move-line="handleMoveLineEvent(sceneIdx, $event)"
            @update-line="$emit('update-line', sceneIdx, $event)"
          />
        </div>
      </div>
    </div>
  </div>
</template>
```

#### SceneItem.vue（シーン専用コンポーネント）
- シーンの表示・編集機能
- シーン内のセリフ一覧表示
- LineItemコンポーネントの管理

#### LineItem.vue（セリフ専用コンポーネント）
- セリフの表示・編集機能
- キャラクター選択機能
- 感情表現の管理

### 3. イベント通信の設計
親子間のイベント通信を以下のように設計したの：

```javascript
// ScriptContentDisplay.vue
const emit = defineEmits([
  "add-scene",
  "add-line-to-scene",
  "delete-scene",
  "delete-line",
  "move-scene",
  "move-line",
  "update-scene",
  "update-line",
]);

// セリフ移動イベントの処理
function handleMoveLineEvent(sceneIndex, moveEvent) {
  const { fromIndex, toIndex } = moveEvent;
  emit('move-line', sceneIndex, fromIndex, toIndex);
}
```

### 4. 編集状態の管理
編集状態は親コンポーネントで一元管理：

```javascript
// インライン編集用の状態管理
const editingItem = ref(null);

// シーンの編集を開始
function startSceneEdit(sceneIndex) {
  editingItem.value = `scene-${sceneIndex}`;
}

// シーンの編集を保存
function saveSceneEdit(sceneIndex, updatedScene) {
  emit('update-scene', sceneIndex, updatedScene);
  editingItem.value = null;
}
```

## 遭遇した問題と解決策

### 問題1: テンプレートの構造が複雑すぎる
**解決策**: 役割ごとにコンポーネントを分離し、それぞれに専用のテンプレートを作成

### 問題2: イベント通信が複雑
**解決策**: 親コンポーネントで統一的なイベント命名規則を採用し、子コンポーネントからのイベントを適切に中継

### 問題3: 編集状態の管理が分散
**解決策**: 編集状態は親コンポーネントで一元管理し、子コンポーネントには`is-editing`プロパティで状態を渡す

## コードの改善点

### Before（400行以上の巨大コンポーネント）
```vue
<template>
  <div class="bg-white rounded-lg shadow-sm border">
    <!-- 複雑なシーン編集テンプレート -->
    <div v-if="editingItem === `scene-${idx}` && !readOnly" class="space-y-3">
      <!-- 大量のインライン編集コード -->
    </div>
    <!-- 複雑なセリフ編集テンプレート -->
    <div v-if="editingItem === `line-${idx}-${lineIdx}` && !readOnly" class="space-y-3">
      <!-- 大量のインライン編集コード -->
    </div>
  </div>
</template>
```

### After（130行のシンプルなコンポーネント）
```vue
<template>
  <div class="bg-white rounded-lg shadow-sm border">
    <SceneItem
      v-for="(scene, sceneIdx) in scriptContent"
      :key="scene.id"
      :scene="scene"
      :scene-index="sceneIdx"
      :available-characters="availableCharacters"
      :read-only="readOnly"
      :is-editing="editingItem === `scene-${sceneIdx}`"
      @start-edit="startSceneEdit(sceneIdx)"
      @save-edit="saveSceneEdit(sceneIdx, $event)"
    />
  </div>
</template>
```

## 学んだこと

### 1. 単一責任の原則の重要性
各コンポーネントが明確な役割を持つことで、コードの理解とメンテナンスが格段に楽になったわ。

### 2. イベント通信の設計
親子間のイベント通信を適切に設計することで、複雑な機能でも整理された構造を保てるの。

### 3. 段階的なリファクタリング
一度に全てを変更するのではなく、段階的にコンポーネントを分離することで、安全にリファクタリングできたわ。

## 今後の改善案

1. **キーボードショートカット対応**: 各コンポーネントでキーボードナビゲーションを強化
2. **アクセシビリティ向上**: ARIA属性の追加とスクリーンリーダー対応
3. **パフォーマンス最適化**: 大量のシーンがある場合の仮想スクロール対応
4. **テスト追加**: 各コンポーネントの単体テストを作成

コンポーネントの細分化って、最初は面倒に感じるけど、結果的に開発効率が大幅に向上するのよね。これで台本エディターがもっと使いやすくなるわ〜♪

---

*Programming Okama Bar "Fatal Error"*  
*ママより愛を込めて* 💖
