# 日記 002: 段階的リファクタリングの実践とLangChain導入記録

## この記事で学べること 📚
- **段階的リファクタリング**の実践手法（23箇所のlocalStorage安全移行）
- **APIキー管理のセキュリティ設計**（永続化 vs セッション選択制）
- **LangChain活用術**：複数LLMプロバイダーの統一インターフェース実装
- **Vue.js設定画面UI設計**：カード式レイアウトと動的フォーム連携
- **企業級AI管理システム**への進化過程

**対象読者**: Vue.js中級者、セキュリティ配慮したフロントエンド設計者、AI統合システム開発者

## localStorage完全撤廃作戦の実行 🔥

### 発見した残党たち
プロジェクト全体を見直した結果、まだlocalStorageを直接使用している箇所が発見されました：

- **Project/Edit.vue**: プロジェクト編集画面でまだ使用
- **Project/Index.vue**: プロジェクト一覧でも残存
- **Settings/Partials/SettingsForm.vue**: 設定画面のAPIキー保存も直接使用

### 完全撤廃の成果
```bash
# 修正前
23 total results (localStorage使用箇所)

# 修正後  
No matches found ✨
```

### 各ファイルの改修内容

**Project/Edit.vue**
```javascript
// 旧: localStorage直接操作
const data = localStorage.getItem(LS_KEY);
const projects = data ? JSON.parse(data) : [];

// 新: 美しいdataService使用
const found = await getProject(projectId);
await updateProject(projectId, { characters: [...] });
```

**Project/Index.vue**
```javascript
// 旧: 同期的な操作
function saveProjects() {
  localStorage.setItem(LS_KEY, JSON.stringify(projects.value));
}

// 新: 非同期で安全
async function saveProject() {
  await createProject({ name, description, characters: [] });
  await loadProjects();
}
```

**Settings/Partials/SettingsForm.vue**
```javascript
// 旧: 設定も直接localStorage
localStorage.setItem("openai_api_key", apiKey.value);

// 新: 統一されたサービス経由
await saveSetting("openai_api_key", apiKey.value);
```

## APIキー保存方式の革命 🔐

### セキュリティとユーザビリティの両立
ユーザーが選択できる2つの保存方式を実装：

- **🔒 ブラウザに保存**: LocalStorageで永続保存（再起動後も残る）
- **⏱️ セッションのみ**: SessionStorageで一時保存（ブラウザ終了で消去）

### 実装の工夫ポイント
```vue
<!-- 直感的なラジオボタンUI -->
<label class="flex items-center cursor-pointer">
  <input v-model="saveMethod" type="radio" value="persistent" />
  <span>{{ $t("saveToBrowser") }}
    <span class="text-gray-500 text-xs block">
      {{ $t("saveToBrowserDesc") }}
    </span>
  </span>
</label>
```

**インテリジェントな読み込み**
```javascript
// セッション優先、次に永続化をチェック
const sessionKey = sessionStorage.getItem(SESSION_KEY);
if (sessionKey) {
  apiKey.value = sessionKey;
  saveMethod.value = "session";
  return;
}
```

**重複回避の仕組み**
- セッション保存時は永続化を自動削除
- 永続化保存時はセッションを自動削除
- 混乱を避けるスマートな設計

### 状態表示の親切設計
現在の保存状態を視覚的に表示：
- 🔒 ブラウザに保存されています
- ⏱️ セッション中のみ保存されています  
- ❌ 保存されていません

### APIキー管理ユーティリティの新設
`apiKeyManager.js`という専用ユーティリティを作成：
```javascript
// 他のファイルからも簡単にAPIキー取得
const apiKey = await getApiKey();
const hasKey = await hasApiKey();
```

### APIキー削除機能の追加 🗑️
保存されたAPIキーを削除する機能も実装：

**実装した削除機能**
```vue
<!-- 削除ボタン（保存されている場合のみ表示） -->
<button
  v-if="currentStorageType !== 'none'"
  @click="clearApiKey"
  class="ml-2 px-2 py-1 text-xs bg-red-100 text-red-600 rounded hover:bg-red-200 transition-colors cursor-pointer"
  type="button"
>
  {{ $t("deleteKey") }}
</button>
```

**スマートな削除ロジック**
```javascript
async function clearApiKey() {
  if (currentStorageType.value === "persistent") {
    // 永続化ストレージをクリア
    await clearPersistentApiKey();
  } else if (currentStorageType.value === "session") {
    // セッションストレージをクリア
    sessionStorage.removeItem(SESSION_KEY);
  }
  
  // フォームもリセット
  apiKey.value = "";
  saveMethod.value = "persistent";
}
```

## LangChain導入と多社LLM対応 🚀

### LangChainとプロバイダーパッケージのインストール
```bash
npm install langchain @langchain/openai @langchain/anthropic @langchain/google-genai @langchain/community
```

### 対応プロバイダー
- 🤖 **OpenAI**: GPT-4, GPT-4-turbo, GPT-3.5-turbo, GPT-4o, GPT-4o-mini
- 🎭 **Anthropic**: Claude-3 Opus, Sonnet, Haiku, Claude-3.5 Sonnet  
- 🔍 **Google**: Gemini Pro, Gemini Pro Vision, Gemini-1.5 Pro, Gemini-1.5 Flash

## 複数LLM設定管理システム 💾

### 複数設定管理機能（llmService.js拡張）
**設定の保存・管理**
```javascript
// 複数設定を保存
export async function saveLLMConfig(config) {
  const newConfig = {
    id: config.id || Date.now().toString(),
    name: config.name,
    provider: config.provider,
    apiKey: config.apiKey,
    defaultModel: config.defaultModel,
    createdAt: new Date().toISOString(),
  };
  // ...保存処理
}

// アクティブ設定の管理
export async function setActiveLLMConfig(configId);
export async function getActiveLLMConfig();
```

**柔軟なLLMインスタンス作成**
```javascript
// 設定IDとモデルを指定して作成
export async function createLLMInstance(configId = null, modelName = null) {
  // 指定された設定またはアクティブ設定を使用
  // 指定されたモデルまたはデフォルトモデルを使用
}
```

### 設定画面の大幅リニューアル 🎨
単純なフォームから、本格的な設定管理システムに大進化！

**設定一覧ビュー**
- 📋 **保存済み設定の一覧表示**（カード形式）
- 🎯 **アクティブ設定の明示**（青いバッジ表示）
- ⭐ **設定の切り替え**（ワンクリックでアクティブ変更）
- ✏️ **編集・削除機能**（各設定個別に管理）

**設定追加・編集フォーム**
- ️**設定名の指定**（自動生成も可能）
- 🤖 **プロバイダー選択**（アイコン付きカード）
- 🔧 **デフォルトモデル選択**（プロバイダー連動）
- 🧪 **設定テスト機能**（保存前に検証）

**インテリジェント機能**
```javascript
// 設定名の自動生成（重複回避）
const configName = await generateConfigName('openai');
// → "OpenAI" または "OpenAI (2)" など

// プロバイダー変更時の自動設定
watch(() => formData.value.provider, async (newProvider) => {
  formData.value.defaultModel = PROVIDER_INFO[newProvider].defaultModel;
  if (!formData.value.name) {
    formData.value.name = await generateConfigName(newProvider);
  }
});
```

### 台本生成画面の拡張 🎬
台本編集画面でもLLM設定とモデルを選択できるように進化！

**生成設定セクション**
```vue
<!-- LLM設定とモデル選択 -->
<div class="mb-6 p-4 bg-gray-50 rounded-lg">
  <h4>生成設定</h4>
  <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
    <!-- LLM設定選択 -->
    <select v-model="selectedLLMConfigId">
      <option v-for="config in availableLLMConfigs" :value="config.id">
        {{ config.name }} ({{ PROVIDER_INFO[config.provider]?.name }})
      </option>
    </select>
    
    <!-- モデル選択 -->
    <select v-model="selectedModel">
      <option v-for="model in availableModels" :value="model">
        {{ model }}
      </option>
    </select>
  </div>
</div>
```

**動的な設定管理**
- **設定変更時の自動モデル更新**
- 🎯 **アクティブ設定の自動選択**
- ⚠️ **設定不足時の警告とリンク**
- 🎨 **現在の設定の視覚的表示**

**生成時の設定指定**
```javascript
// 選択した設定とモデルで生成
generatedContent = await generateAIScript(
  script.value, 
  project.value, 
  { 
    configId: selectedLLMConfigId.value, 
    modelName: selectedModel.value 
  }
);
```

## 技術的な学び 📚

### LangChainの威力
最初は新しいライブラリの学習コストを懸念しましたが、LangChainの統一されたインターフェースによって：

**各社のAPIを統一**
```javascript
// どのプロバイダーでも同じ使い方 ✨
const llm = await createLLMInstance();
const response = await llm.invoke(prompt);
```

OpenAI、Anthropic、Googleのどれを使っても同じコードで動作します。

### 段階的リファクタリングの威力
- 一気にやろうとせず、少しずつ改善していくことの重要性
- 統一性がもたらすコードの美しさ
- Promise対応による将来の拡張性確保
- エラーハンドリングの統一によるユーザー体験向上

### 最終的な到達点

**設定画面の最終仕様**
- 🤖 **LLMプロバイダー選択**（OpenAI、Anthropic、Google）
- **モデル選択**（プロバイダーに応じて動的更新）
- 🧪 **APIキーテスト**（実際にAPIを呼び出して検証）
- 🔑 **APIキー入力**（パスワード形式）
- 🔒 **永続化保存**（ブラウザに残る）
- ⏱️ **セッション保存**（今回のみ）
- 📊 **現在の状態表示**（何がどこに保存されているか）
- 🗑️ **削除ボタン**（保存済みキーをワンクリックで削除）
- 🌍 **完全i18n対応**（日本語・英語）
- ✨ **美しいTailwind CSS UI**

**台本生成システム**
- 🚀 **LangChain統合**: 複数AIプロバイダーを統一インターフェースで
- 🎯 **AI台本生成**: 本格的なプロンプトエンジニアリング
- 🛡️ **エラーハンドリング**: AI失敗時のサンプル生成フォールバック
- 💾 **自動保存**: 生成完了後の状態更新
- 🔧 **設定連携**: 選択したプロバイダー・モデルで生成

**最終戦果**
- **23箇所→0箇所**: localStorage直接使用を完全排除
- **6ファイル修正**: Project/Edit.vue, Project/Index.vue, Settings/SettingsForm.vue他
- **統一されたAPI**: 全データ操作がdataService.js経由
- **LangChain統合**: OpenAI、Anthropic、Google対応
- **AI台本生成**: 本格的なAI生成機能実装
- **エラーなし**: 全ファイルでコンパイルエラーゼロ達成

このプロジェクトは「美しいデータアクセス層を持つVueアプリ」から「企業級AI台本生成システム」に進化を遂げました。

---

*技術ブログ記事*  
*2025年7月8日*
