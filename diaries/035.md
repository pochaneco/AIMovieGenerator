# 035. インライン編集統一とUI改善 - シーンとセリフの編集体験を統一したわよ！

## 今日の気持ち
今日は編集UIの大改革よ！シーンとセリフの編集を統一して、もっと直感的で使いやすくしたの。ボタンだらけのモーダルから、ダブルクリックでサクッと編集できるインライン編集に変更。これで編集作業がめっちゃスムーズになったわ！

## この記事で学べること
- Vue 3でのインライン編集の実装パターン
- 複数のアイテムタイプ（シーン・セリフ）の統一編集UI
- 新規アイテム追加時の自動編集モード実装
- イベントドリブンな親子コンポーネント連携
- プロンプトベースUIからフォームベースUIへの移行

## 対象読者
- Vue 3でリッチなフォーム編集機能を実装したい人
- ユーザビリティを重視したUI設計を学びたい人
- インライン編集のベストプラクティスを知りたい人

## 実装した内容

### 1. インライン編集の統一実装

シーンとセリフの編集を同じパターンで実装したの。ダブルクリックで編集モードに切り替わるのがポイント！

```vue
<!-- ScriptContentDisplay.vue -->
<template>
  <div class="script-item-container">
    <!-- シーン編集 -->
    <div v-if="item.type === 'scene'" class="scene-item">
      <!-- 編集モード -->
      <div v-if="editingItem === idx && !readOnly" class="space-y-3" :data-edit-index="idx">
        <input
          v-model="editForm.title"
          @keyup.enter="saveInlineEdit"
          @keyup.escape="cancelInlineEdit"
          class="w-full text-lg font-bold text-blue-800 bg-transparent border-b-2 border-blue-300 focus:outline-none focus:border-blue-500"
          placeholder="シーンタイトル"
        />
        <textarea
          v-model="editForm.content"
          @keyup.ctrl.enter="saveInlineEdit"
          @keyup.escape="cancelInlineEdit"
          rows="3"
          class="w-full text-gray-700 bg-transparent border border-gray-300 rounded px-2 py-1 focus:outline-none focus:border-blue-500"
          placeholder="シーンの説明"
        ></textarea>
        <input
          v-model="editForm.duration"
          @keyup.enter="saveInlineEdit"
          @keyup.escape="cancelInlineEdit"
          class="w-32 text-sm text-gray-600 bg-transparent border-b border-gray-300 focus:outline-none focus:border-blue-500"
          placeholder="時間"
        />
        <div class="flex gap-2 mt-2">
          <button @click="saveInlineEdit" class="px-3 py-1 bg-blue-500 text-white text-xs rounded hover:bg-blue-600">
            保存
          </button>
          <button @click="cancelInlineEdit" class="px-3 py-1 bg-gray-500 text-white text-xs rounded hover:bg-gray-600">
            キャンセル
          </button>
        </div>
      </div>
      
      <!-- 表示モード -->
      <div 
        v-else 
        @dblclick="startInlineEdit(idx, item)"
        :class="{ 'cursor-pointer hover:bg-blue-100': !readOnly }"
        class="rounded p-1"
        :title="readOnly ? '' : 'ダブルクリックで編集'"
      >
        <h3 class="font-bold text-lg text-blue-800 mb-2">{{ item.title }}</h3>
        <p class="text-gray-700">{{ item.content }}</p>
        <p v-if="item.duration" class="text-sm text-gray-500 mt-1">時間: {{ item.duration }}</p>
      </div>
    </div>

    <!-- セリフ編集（同じパターン） -->
    <div v-else-if="item.type === 'line'" class="line-item">
      <!-- 編集モード -->
      <div v-if="editingItem === idx && !readOnly" class="space-y-3" :data-edit-index="idx">
        <select
          v-model="editForm.character"
          class="bg-green-100 text-green-800 text-xs font-semibold px-2 py-1 rounded border focus:outline-none focus:border-green-500"
        >
          <option v-for="character in availableCharacters" :key="character.name" :value="character.name">
            {{ character.name }}
          </option>
        </select>
        <textarea
          v-model="editForm.content"
          @keyup.ctrl.enter="saveInlineEdit"
          @keyup.escape="cancelInlineEdit"
          rows="2"
          class="w-full text-gray-800 bg-transparent border border-gray-300 rounded px-2 py-1 focus:outline-none focus:border-green-500"
          placeholder="セリフ内容"
        ></textarea>
        <input
          v-model="editForm.emotion"
          @keyup.enter="saveInlineEdit"
          @keyup.escape="cancelInlineEdit"
          class="w-32 text-sm text-gray-600 bg-transparent border-b border-gray-300 focus:outline-none focus:border-green-500"
          placeholder="感情"
        />
        <div class="flex gap-2 mt-2">
          <button @click="saveInlineEdit" class="px-3 py-1 bg-green-500 text-white text-xs rounded hover:bg-green-600">
            保存
          </button>
          <button @click="cancelInlineEdit" class="px-3 py-1 bg-gray-500 text-white text-xs rounded hover:bg-gray-600">
            キャンセル
          </button>
        </div>
      </div>
      
      <!-- 表示モード -->
      <div 
        v-else
        @dblclick="startInlineEdit(idx, item)"
        :class="{ 'cursor-pointer hover:bg-green-50': !readOnly }"
        class="flex items-start gap-3 rounded p-1"
        :title="readOnly ? '' : 'ダブルクリックで編集'"
      >
        <span class="bg-green-100 text-green-800 text-xs font-semibold px-2 py-1 rounded">
          {{ item.character }}
        </span>
        <div class="flex-1">
          <p class="text-gray-800">{{ item.content }}</p>
          <p v-if="item.emotion && item.emotion !== '普通'" class="text-sm text-gray-500 mt-1">
            感情: {{ item.emotion }}
          </p>
        </div>
      </div>
    </div>
  </div>
</template>
```

### 2. 自動編集モードの実装

新しいアイテムを追加した時に、自動で編集モードに入る機能を実装したの。これが結構複雑だったけど、Custom Eventsを使って解決！

```javascript
// Edit.vue - 新規アイテム追加時の自動編集
function addSceneAt(position) {
  const newScene = {
    id: Date.now() + Math.random(),
    type: "scene",
    title: "新しいシーン",
    content: "シーンの説明を入力してください",
    duration: "3分",
  };

  scriptContent.value.splice(position, 0, newScene);
  
  // 追加されたシーンを即座に編集モードに
  nextTick(() => {
    const event = new CustomEvent('start-edit', {
      detail: { index: position, item: newScene }
    });
    document.dispatchEvent(event);
  });
}

function addLineAt(position) {
  const characters = project.value?.characters || [];
  const defaultCharacter = characters.length > 0 ? characters[0].name : "キャラクター";

  const newLine = {
    id: Date.now() + Math.random(),
    type: "line",
    character: defaultCharacter,
    content: "新しいセリフを入力してください",
    emotion: "普通",
  };

  scriptContent.value.splice(position, 0, newLine);
  
  // 追加されたセリフを即座に編集モードに
  nextTick(() => {
    const event = new CustomEvent('start-edit', {
      detail: { index: position, item: newLine }
    });
    document.dispatchEvent(event);
  });
}
```

```javascript
// ScriptContentDisplay.vue - Custom Eventの受信
// 外部からの編集モード開始イベントを受信
function handleStartEdit(event) {
  const { index, item } = event.detail;
  startInlineEdit(index, item);
}

onMounted(() => {
  document.addEventListener('start-edit', handleStartEdit);
});

onUnmounted(() => {
  document.removeEventListener('start-edit', handleStartEdit);
});

// インライン編集を開始
function startInlineEdit(idx, item) {
  if (props.readOnly) return;
  
  editingItem.value = idx;
  editForm.value = { ...item };
  
  // 次のティックで入力フィールドにフォーカス
  nextTick(() => {
    const inputElements = document.querySelectorAll(`[data-edit-index="${idx}"] input, [data-edit-index="${idx}"] textarea`);
    if (inputElements.length > 0) {
      inputElements[0].focus();
    }
  });
}
```

### 3. 親子コンポーネント間の状態管理

親コンポーネント（Edit.vue）と子コンポーネント（ScriptContentDisplay.vue）の間でのデータ同期を`update-item`イベントで実装したの。

```javascript
// ScriptContentDisplay.vue - 編集結果の親への通知
function saveInlineEdit() {
  if (editingItem.value === null) return;
  
  const updatedItem = {
    ...props.scriptContent[editingItem.value],
    ...editForm.value,
  };
  
  // 親コンポーネントに変更を通知
  emit('update-item', editingItem.value, updatedItem);
  
  editingItem.value = null;
  editForm.value = {};
}

// Edit.vue - 子コンポーネントからの更新を受信
function updateItem(index, updatedItem) {
  if (index >= 0 && index < scriptContent.value.length) {
    scriptContent.value[index] = updatedItem;
  }
}
```

### 4. キーボードショートカット

編集体験を向上させるため、各種キーボードショートカットを実装したの。

```javascript
// Enter: 保存
// Ctrl+Enter: 改行可能なテキストエリアでの保存
// Escape: キャンセル

@keyup.enter="saveInlineEdit"
@keyup.ctrl.enter="saveInlineEdit"
@keyup.escape="cancelInlineEdit"
```

### 5. フォーカス管理

新規アイテム追加時に自動でフォーカスが当たるように実装したの。

```javascript
// data-edit-index属性を使ってフォーカス対象を特定
nextTick(() => {
  const inputElements = document.querySelectorAll(`[data-edit-index="${idx}"] input, [data-edit-index="${idx}"] textarea`);
  if (inputElements.length > 0) {
    inputElements[0].focus();
  }
});
```

## 学んだこと

### 1. Custom Eventsの活用
親子コンポーネント間でのカスタムイベントは、複雑なワークフローを実現する強力な手段だった。今回は新規アイテム追加後の自動編集モードで活用。

### 2. nextTick()の重要性
DOM更新後の処理では`nextTick()`が必須。特にフォーカス管理では絶対に必要。

### 3. data-*属性の活用
`data-edit-index`属性を使って、編集対象要素の特定を効率化。QuerySelectorでのターゲティングが楽になった。

### 4. プロンプトベースUIの課題
元々はprompt()を使っていたけど、UXが悪すぎた。インライン編集にしたことで、操作性が格段に向上。

## 今後の改善点

1. **キーボードナビゲーション**: Tab移動やArrowキーでの項目移動
2. **バリデーション**: 入力内容のリアルタイム検証
3. **アクセシビリティ**: スクリーンリーダー対応
4. **アニメーション**: 編集モード切り替え時のスムーズな遷移

## まとめ

編集UIの統一化は想像以上に複雑だったけど、結果的にすごく使いやすくなったわ！特に新規アイテム追加時の自動編集モードは、ユーザーの作業フローを大幅に改善してくれる。Vue 3の reactivity system と組み合わせることで、レスポンシブで直感的な編集体験を実現できたの。

モーダルベースからインライン編集への移行は、単なるUI変更以上の価値があったのよ。ユーザーが「編集する」という行為に対する心理的ハードルを下げることで、より気軽に台本を修正できるようになったからね！

これで台本編集がもっと楽しくなるはず！次はもっと細かいUXの改善に取り組んでいくわよ～♪
