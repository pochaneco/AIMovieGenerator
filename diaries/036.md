# 036. 台本構造の大改革 - LineをSceneの子要素にして階層構造を実現！

## 今日の気持ち
今日は台本の構造を根本から変更したの！LineがSceneの独立した兄弟だったのを、Sceneの子要素にして、より論理的で直感的な階層構造にしたわ。この変更はかなり大規模だったけど、これで台本がより自然な構造になったの！

## この記事で学べること
- 既存データ構造の段階的リファクタリング方法
- ネストしたデータ構造でのVue.jsコンポーネント設計
- 既存データの下位互換性を保った構造変換
- 階層的なインライン編集UIの実装
- 複雑なデータ構造での親子コンポーネント間イベント処理

## 対象読者
- 大規模なデータ構造変更を計画している人
- ネストしたデータでのUI設計を学びたい人
- 既存データの移行戦略を知りたい人

## 実装した内容

### 1. 新しい台本構造の定義

#### 旧構造（フラット）
```javascript
[
  { id: 1, type: 'scene', title: 'シーン1', content: '...', duration: '3分' },
  { id: 2, type: 'line', character: 'キャラA', content: 'セリフ1', emotion: '喜び' },
  { id: 3, type: 'line', character: 'キャラB', content: 'セリフ2', emotion: '普通' },
  { id: 4, type: 'scene', title: 'シーン2', content: '...', duration: '2分' },
  { id: 5, type: 'line', character: 'キャラA', content: 'セリフ3', emotion: '悲しみ' },
]
```

#### 新構造（ネスト）
```javascript
[
  {
    id: 1,
    type: 'scene',
    title: 'シーン1',
    content: 'シーンの説明',
    duration: '3分',
    lines: [
      { id: 2, type: 'line', character: 'キャラA', content: 'セリフ1', emotion: '喜び' },
      { id: 3, type: 'line', character: 'キャラB', content: 'セリフ2', emotion: '普通' },
    ]
  },
  {
    id: 4,
    type: 'scene',
    title: 'シーン2',
    content: 'シーンの説明',
    duration: '2分',
    lines: [
      { id: 5, type: 'line', character: 'キャラA', content: 'セリフ3', emotion: '悲しみ' },
    ]
  }
]
```

### 2. 台本生成の構造変更

`scriptGenerator.js`を修正して、新しいネスト構造を生成するようにしたの。

```javascript
// scriptGenerator.js - 新しい構造での台本生成
export function generateStructuredScript(script, project) {
  const scriptContent = [];
  
  // シーン1: オープニング
  const scene1 = {
    id: Date.now() + 3,
    type: "scene",
    title: "シーン1: オープニング",
    content: "物語の始まりです。主人公が登場します。",
    duration: "3分",
    lines: [], // セリフを格納する配列
  };

  if (characters.length >= 2) {
    scene1.lines.push({
      id: Date.now() + 4,
      type: "line",
      character: characters[0].name,
      content: `こんにちは、${characters[1].name}さん。`,
      emotion: "親しみやすい",
    });

    scene1.lines.push({
      id: Date.now() + 5,
      type: "line",
      character: characters[1].name,
      content: "はい、こんにちは。今日はいい天気ですね。",
      emotion: "穏やか",
    });
  }

  scriptContent.push(scene1);
  return scriptContent;
}
```

### 3. UIコンポーネントの階層表示

`ScriptContentDisplay.vue`を大幅に修正して、シーンとその中のセリフを階層的に表示するようにしたの。

```vue
<!-- ScriptContentDisplay.vue - 新しい階層表示 -->
<template>
  <div v-for="(item, idx) in scriptContent" :key="item.id">
    <!-- シーンの場合 -->
    <div v-if="item.type === 'scene'" class="scene-container">
      <!-- シーン表示/編集 -->
      <div class="p-4 rounded-lg border bg-blue-50 border-blue-200">
        <div v-if="editingItem === `scene-${idx}`" class="space-y-3">
          <!-- シーン編集フォーム -->
          <input v-model="editForm.title" placeholder="シーンタイトル" />
          <textarea v-model="editForm.content" placeholder="シーンの説明"></textarea>
          <input v-model="editForm.duration" placeholder="時間" />
        </div>
        <div v-else @dblclick="startInlineEdit(`scene-${idx}`, item)">
          <!-- シーン表示 -->
          <h3 class="font-bold text-lg text-blue-800">{{ item.title }}</h3>
          <p class="text-gray-700">{{ item.content }}</p>
        </div>
      </div>

      <!-- シーン内のセリフ一覧 -->
      <div v-if="item.lines && item.lines.length > 0" class="ml-6 mt-2 space-y-2">
        <div v-for="(line, lineIdx) in item.lines" :key="line.id">
          <div class="p-3 rounded-lg border bg-green-50 border-green-200">
            <div v-if="editingItem === `line-${idx}-${lineIdx}`">
              <!-- セリフ編集フォーム -->
              <select v-model="editForm.character">
                <option v-for="character in availableCharacters" :value="character.name">
                  {{ character.name }}
                </option>
              </select>
              <textarea v-model="editForm.content" placeholder="セリフ内容"></textarea>
            </div>
            <div v-else @dblclick="startInlineEdit(`line-${idx}-${lineIdx}`, line)">
              <!-- セリフ表示 -->
              <span class="bg-green-100 text-green-800 text-xs font-semibold px-2 py-1 rounded">
                {{ line.character }}
              </span>
              <p class="text-gray-800">{{ line.content }}</p>
            </div>
          </div>
        </div>
      </div>

      <!-- シーン内にセリフ追加ボタン -->
      <div class="ml-6 mt-2 flex justify-center">
        <button @click="$emit('add-line-to-scene', idx)">
          + セリフを追加
        </button>
      </div>
    </div>
  </div>
</template>
```

### 4. 編集イベントの階層化

新しい構造に対応したイベントシステムを実装したの。

```javascript
// ScriptContentDisplay.vue - 階層化されたイベント
const emit = defineEmits([
  'add-scene',
  'add-line-to-scene',
  'delete-scene',
  'delete-line',
  'move-scene',
  'move-line',
  'update-scene',
  'update-line',
]);

// インライン編集の保存
function saveInlineEdit() {
  const editId = editingItem.value;
  const updatedItem = { ...editForm.value };

  // シーンまたはセリフかを判断
  if (editId.startsWith('scene-')) {
    const sceneIndex = parseInt(editId.split('-')[1]);
    emit('update-scene', sceneIndex, updatedItem);
  } else if (editId.startsWith('line-')) {
    const [, sceneIndex, lineIndex] = editId.split('-').map(Number);
    emit('update-line', sceneIndex, lineIndex, updatedItem);
  }
}
```

### 5. 親コンポーネントでの階層処理

`Edit.vue`で新しい階層構造に対応した編集関数を実装したの。

```javascript
// Edit.vue - 階層対応の編集関数

// シーンにセリフを追加
function addLineToScene(sceneIndex) {
  const scene = scriptContent.value[sceneIndex];
  if (!scene || scene.type !== 'scene') return;
  
  const newLine = {
    id: Date.now() + Math.random(),
    type: "line",
    character: defaultCharacter,
    content: "新しいセリフを入力してください",
    emotion: "普通",
  };

  if (!scene.lines) {
    scene.lines = [];
  }
  scene.lines.push(newLine);
}

// セリフの更新
function updateLine(sceneIndex, lineIndex, updatedLine) {
  const scene = scriptContent.value[sceneIndex];
  if (!scene || scene.type !== 'scene' || !scene.lines) return;
  
  if (lineIndex >= 0 && lineIndex < scene.lines.length) {
    scene.lines[lineIndex] = {
      ...scene.lines[lineIndex],
      ...updatedLine,
    };
  }
}

// セリフの移動
function moveLine(sceneIndex, oldLineIndex, newLineIndex) {
  const scene = scriptContent.value[sceneIndex];
  if (!scene || scene.type !== 'scene' || !scene.lines) return;
  
  const lines = [...scene.lines];
  const [movedLine] = lines.splice(oldLineIndex, 1);
  lines.splice(newLineIndex, 0, movedLine);
  scene.lines = lines;
}
```

### 6. 既存データの変換

既存の台本データを新しい構造に自動変換する機能を実装したの。

```javascript
// Edit.vue - 既存データの変換
function convertToNestedStructure(oldContent) {
  const newContent = [];
  let currentScene = null;
  
  for (const item of oldContent) {
    if (item.type === 'scene') {
      // 前のシーンがある場合は追加
      if (currentScene) {
        newContent.push(currentScene);
      }
      // 新しいシーンを開始
      currentScene = {
        ...item,
        lines: [],
      };
    } else if (item.type === 'line' || item.type === 'narration' || item.type === 'action') {
      // セリフ等はシーンに追加
      if (currentScene) {
        currentScene.lines.push(item);
      } else {
        // シーンがない場合は、デフォルトシーンを作成
        currentScene = {
          id: Date.now() + Math.random(),
          type: 'scene',
          title: 'シーン1',
          content: '自動生成されたシーン',
          duration: '3分',
          lines: [item],
        };
      }
    }
  }
  
  // 最後のシーンを追加
  if (currentScene) {
    newContent.push(currentScene);
  }
  
  return newContent;
}

// 読み込み時の自動変換
async function loadScript() {
  // 既存データが新しいネスト構造かどうかチェック
  const hasNestedStructure = scriptData.structuredContent.some(item => 
    item.type === 'scene' && Array.isArray(item.lines)
  );
  
  if (hasNestedStructure) {
    scriptContent.value = scriptData.structuredContent;
  } else {
    // 古い構造を新しい構造に変換
    scriptContent.value = convertToNestedStructure(scriptData.structuredContent);
  }
}
```

## 学んだこと

### 1. 段階的リファクタリングの重要性
大規模な構造変更は一気にやらず、段階的に進めることが重要。今回も変換関数で既存データとの互換性を保ちながら移行できた。

### 2. ネストしたデータでのUI設計
階層的なデータ構造をUIで表現する際は、視覚的な階層（インデント）と操作の分離（シーンレベル・セリフレベル）を明確にすることが大切。

### 3. イベント名前空間の活用
`scene-${idx}`や`line-${sceneIdx}-${lineIdx}`のような構造化されたIDを使うことで、階層的な編集を効率的に管理できる。

### 4. データ変換における例外処理
既存データの構造が想定と異なる場合に備えて、適切なフォールバック処理を用意することが重要。

## 改善された点

1. **論理的な構造**: シーンとセリフの関係が明確になった
2. **直感的な編集**: シーン内でセリフを追加・編集できるようになった
3. **データの整合性**: セリフが必ずシーンに属するようになった
4. **UI の改善**: 階層表示で台本の構造が分かりやすくなった
5. **下位互換性**: 既存データも自動変換で対応

## 今後の課題

1. **パフォーマンス最適化**: 大きな台本での描画性能
2. **ドラッグ&ドロップ**: シーン間でのセリフ移動
3. **一括操作**: 複数セリフの選択・移動・削除
4. **検索機能**: 階層構造での台本内検索

## まとめ

台本の構造をフラットからネストに変更するのは大変だったけど、結果的にすごく使いやすくなったわ！特に「シーンにセリフを追加」という操作が直感的になったのは大きな改善よ。

データ構造の変更は影響範囲が広いから慎重に進める必要があったけど、変換関数で既存データとの互換性を保ちながら移行できたのは良かった。Vue.jsのリアクティブシステムのおかげで、ネストしたデータでもスムーズに動作するの。

これで台本編集がより論理的で使いやすくなったはず！次はもっと細かいUXの改善に取り組んでいくわよ～♪
